(defun shanks-range-check (model expr min max)
  (and (>= expr min)
       (<= expr max)))

(defun shanks-compile (model expr expected-type)
  (cond ((memq expr '(true false))
         (eq expected-type 'Bool))
        ((integerp expr)
         (case expected-type
           ((U8)
            (shanks-range-check model expr 0 255))
           ((U16)
            (shanks-range-check model expr 0 65535))
           (t (error "Unexpected integer literal"))))
        ((consp expr)
         (case (car expr)
           ((+ - * /)
            (and (shanks-type-check model (second expr) expected-type)
                 (shanks-type-check model (third expr) expected-type)))
           ((and or not)
            (and (eq expected-type 'Bool)
                 (loop for subexpr in (cdr expr)
                       always (shanks-type-check model subexpr 'Bool))))
           ((invoke)
            (let ((package-id (second expr))
                  (type-id (third expr)))

               (t (error "alsk"))))))))

(defun shanks-infer-type (model expr)
  (cond ((memq expr '(true false))
         'Bool)
        ((integerp expr)
         :undecided-integer)
        ((consp expr)
         (case (car expr)
           ((+ - * /)
            (error "TODO"))
           ((variable)
            (error "TODO"))
           ((invoke)
            (let ((object (second expr))
                  (method-id (third expr))
                  (arguments (cdddr expr)))
              (let ((object-type (shanks-infer-type model object)))
                (if (null object-type)
                    :unknown-type
                  (let ((return-types (shanks-class-return-types object-type)))
                    (if (= (length return-types) 1)
                        (first return-types)
                      (push (make-shanks-error :message "Expected single return value")
                            (shanks-model-errors model))))))